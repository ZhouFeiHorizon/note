# 学习讲解笔记



## 2022/1/20



```js
vue-router 路由钩子
// 全局
router.beforeEach((to, from, next){})
router.afterEach((to, from) => {})        
// 路由独享
beforeEnter
// 组件内
beforeRouteEnter
beforeRouteUpdate
beforeRouteLeave


vue 生命周期

beforeCreate 实例化之前
created  实例化 
beforeMount()
mounted() $el

beforeUpdate
updated

beforeDestroy 清除定时/监听事件
destroyed

// 被keep-alive 包裹的
activated() {},
deactivated() {},

keep-alive 标签
include exclude max 

// 父子
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted。

离开页面：实例销毁 --> DOM卸载
parent  beforeDestroy
child   beforeDestroy
child   destroyed
parent  destroyed

component 动态组件，通过is设置要显示的组件
<component is="UserInfo" >

// Vue组件间的传值的几种方式
1. props/emit
2. $attrs/$listeners
3. $refs/$parent/$children/$root/ 
4. vuex
5. 事件总线，通过new Vue去实现 / mitt <==> vue3
6. provide/inject
    // 父组件
    props: {},
    provide() {
        name: this.name,
        user: this.user
    }
    // 子组件
    props: {},
    inject: ['user']
7. 本地存储、全局变量

$attrs 除了 props、class、style 之外的属性
```



## 2022/1/22

### 指令

常用指令 

- v-show    `dispaly none` 的切换
- v-if/v-else

- v-html 
- v-text
- v-for
- v-cloak    [v-cloak] {dispaly:none}
- v-once  静态内容
- v-bind :  v-on @
- 

- v-model  @input  value

```js

// 父组件
// 
// <Child v-model="xxx" :value="sxxxx" @input="onInput($event)"></Child>
// <Child v-model="xxx"></Child>


// 子组件
this.$emit('input', '222')

Vue.directive('darg', {
    inert(el, binding, vndooe),
    update()
})
```



### 修饰

- .lazy、.number、.trim、.enter、.prevent、.self

- `.sync`

  visible.sync

  

```js
// <Child  :visible="sxxxx" @update:visible="onXxx"></Child>
// this.$emit('update:visible', '哈哈哈')
```



### scoped

.a .b {}  ==> .a  .b[data-v-xx]{}

.a /deep/ .b {} ==> .a[data-v-xxx] .b {}

.a >>> .b {} ==> .a[data-v-xxx] .b {}

.a ::v-deep .b {} ==> .a[data-v-xxx] .b {}



``` js
$event 子组件传递过来的值
<Chid v-model="value"></Chid>
<Chid :value="value" @input="value = $event"></Chid>
```



### 响应式

const obj = {a:'aaa'}

obj.a



delete obj.a  ==>  this.$delete (obj, 'a')



obj.key= 'value'

this.$set(obj,  'key', 'value')



Vue.set == this.$set(对象\数组， key值、index， value)



### watch、mixins、组件顺序、组件配置

```js
export default {
  name: "App",
  mixins: [tableMixin],
  components: {},
  inject: ["xxx"],
  // props: ['value', 'visible'],
  props: {
    id: String,
    type: {
      // required: true,
      type: String,
      default: "warning",
      validator(val) {
        return ["primary", "warning", "danger", "success", "info"].includes(val)
      },
    },
      list: {
          type: Array,
          default: () => []
      }
  },
  data() {
    return {
      name: "张三",
      user: { name: "张三", age: 18 },
      loading: true,

      // vue2
      obj: {
        name: "李四~",
      },
      // vue2 会进行深度合并
      // obj  {"name":"李四~","age":19}

      // vue3 { name: "李四~" }
    }
  },
  provide() {
    return {
      userName: this.name,
      user: this.user,
    }
  },
  computed: {
    // fullName() {
    //   return 'xxxxx'
    // }
    fullName: {
      get() {
        return this.$store.state.userName
        // return '李四'
      },
      set(val) {
        this.$store.commit("SET_NAME", val)
      },
    },
  },

  watch: {
    // name(value) {
    //   this.handlerName()
    // }
    // name: {
    //   immediate: true,
    //   deep: true, //
    //   handler(val, oldValue) {
    //     this.handlerName()
    //   },
    // },
    // this.obj.name = 'xxxx' 这样不会执行
    // this.obj = {name: 'xxx'} 这样才会执行
    // obj(value) {
    //   console.log(' value: ', value)
    // }
    //  和上面等价
    // obj: {
    //   handler(value) {
    //     console.log(" value: ", value)
    //   },
    // },
    // this.obj.name = 'xxxx' 这样去修改也能监听
    // obj: {
    //   deep: true, // 深度监听
    //   immediate: true, // 第一次就用执行这个方法，可以理解为在 created 的时候会执行 handler
    //   handler(value) {
    //     console.log(" value: ", value)
    //   },
    // },
    //
    // obj: {
    //   deep: true, // 深度监听
    //   immediate: true, // 第一次就用执行这个方法，可以理解为在 created 的时候会执行 handler
    //   handler: 'handlerName',
    // },
    // ==》
    // obj: 'handlerName'
    
    // '$route.path': {},
    // 'obj.a' : {}
  },

  beforeCreate() {
    console.log("this", this)
  },
  mounted() {
    // this.handlerName()
    this.fullName = "xxxx"
    this.fullName = "xxxx"
    this.fullName = "xxxx"

    //  this.fullName '李四'
  },

  methods: {
    handlerName() {
      this.obj.name = "xxxx"
    },
  },
}
```



### vuex

```js
// state
this.$store.state.userInfo
// getters
this.$store.getters.userInfo

// mutations
this.$store.commit('SET_USER_INFO', '传递数据')

// actions
this.$store.dispatch('logout').then(res => { })

// -----------------------------------
// modules > user
// namespaced: true,

// state 拿 name
this.$store.state.user.avatar
// getters
this.$store.getters.user.avatar

// mutations
this.$store.commit('user/SET_TOKEN', '传递数据')

// actions
this.$store.dispatch('user/login').then(res => { })

// -----------------------------------
// modules > user
// namespaced: false,

// state 拿 name
this.$store.state.user.avatar
// getters
this.$store.getters.user.avatar

// mutations
this.$store.commit('SET_TOKEN', '传递数据')

// actions
this.$store.dispatch('login').then(res => {})
```

```
mapState, mapGetters, mapMutations, mapActions
```



## 2022/1/27



### 模块

-  `commonjs nodejs`

  ```js
  require('xxx')
  module.export
  ```

  

- AMD  

```js
// requirejs
define(['juqery', 'vue'], function($, Vue) {
  $('#app')
    
   new Vue({})
})

CMD seaJs
define(['juqery', 'vue'], function($, Vue) {
  $('#app')
    
   new Vue({})
})
```

- ESM   ES6 import export 

  ```js
  import $ from 'jquery'
  export default $
  ```

  

- UMD 通用加载模块

  ```js
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.Vue = factory());
  }(this, function () { 'use strict';
  ```

  



### 指令

```html
<template>
  <div v-dragx.xxx="'333'">{{sdfd}}</div>
</template>
```

```js


created() {},
// template 执行
beforeMount() {}
// 
mounted() {}

Vue.directive('dragx', {  
  // 生命周期
  // el dom元素
  bind(el, binding, vnode) {
    const value = binding.value
    // binding.name  => dragx
    // binding.modifiers ==> xxx
    el.style.color = 'red'
  },
  inserted() {},
  update() {},
  componentUpdated() {},
  unbind() {}
})

// bind update 
Vue.directive('dragx', function(el, binding, vnode) {

})
```



## 2021/1/28

### 常用的h5标签



### 盒模型 *

content padding border margin

标准的盒模型  宽高 content

IE和的盒模型  宽高  content+padding+border

box-sizing  `border-box` `content-box`

### margin合并 *

margin合并会在垂直方向上合并， 会取最大的值

解决

1. 设置的时候就设置最大值
2. display: inline-block;
3. float: left;



### margin塌陷 *

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    .parent {
      width: 500px;
      height: 500px;
      background-color: rgb(168, 238, 121);
      /* border: 1px solid red; */
      /* overflow: hidden; */
      /* display: inline-block; */
      /* position: absolute; */
    }
    .child {
      margin-top: 200px;
      width: 200px;
      height: 200px;
      background-color: gray;
      float: left;
    }

    /* 
      解决方法, 在父盒子上加 border\触发BFC
      1. 
      2. overflow: hidden;
      3. display: inline-block;
      4. 父/子 position: absolute;
    */
  </style>
</head>
<body>
  <div class="parent">
    <div class="child"></div>
  </div>
</body>
</html>
```



解决方法, 在父盒子上加 border\触发BFC

### BFC *

> 块级格式化上下文 (block format context) 容器内的元素不会影响容器外的元素.

**BFC的布局规则** *

- 内部的Box会在垂直方向，一个接一个地放置。

- Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。

- 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。

- BFC的区域不会与float box重叠。

- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

- 计算BFC的高度时，浮动元素也参与计算。
  

**触发BFC的条件** *

- 根元素 html

- float的值不是none。
- position的值不是static或者relative。
- display的值是inline-block、table-cell、flex、table-caption或者inline-flex
- overflow的值不是visible



### css

​    /* 常用的行内元素 span a b em strong  */

​    /* 行内块级 input img  */

​    /* 块级 h1-h6 p div table, tr, td, ul,  */



**居中方法**

```text
<!-- 水平居中 -->
<!--
行内，行内块级 
text-aligin: center;
flex 
margin: 0 auto block
postion  left:50%
margin-left  
transform: translateX(-50%);
-->
```



### **css 选择器**

id选择器（ #myid） 

类选择器（.myclassname） 

标签选择器（div, h1, p）相邻选择器（h1 + p） 

子选择器（ul > li）后代选择器（li a）

属性选择器（a[rel = "external"]） 

伪类选择器（a: hover, li:nth-child）

通配符选择器（ * ） 





## 2022/1/29~2020/1/30

- 基本数据类型 *

  ```js
  string boolean number object undefined null symbol BigInt
  ```

- call、apply 、bind改变this指向

  ```js
  obj.call(this指向, 参数1， 参数2)
  obj.apply(this指向, [参数1， 参数2])
  
  function fn(age) {
      console.log('this')
  }
  const obj = {name:''}
  const result = fn.bind(obj)
  result(20)
  
  ```

- 类数组：不是真正的数组

  ```js
  0: "111"
  1: 222
  2: "22"
  callee: ƒ test()
  length: 3
  ```

  类数组转数组

  - Array.from
  - ...扩展运算符

- 箭头函数 *

  - 箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值，这就意 

    味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this

  - 箭头函数没有自己的 `arguments` 对象，但是可以访问外围函数的 `arguments `对象

  - 不能通过 new 关键字调用(不能作为构造函数)，同样也没有 new.target 值和原型

- 防抖和节流*

  - 防抖 **所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。**
  - 节流 **就是指连续触发事件但是在 n 秒中只执行一次函数**

- 事件捕获、事件冒泡*

  - 事件捕获 （ 从上到下，从外到内）  --> 处于目标事件（触发）-->事件冒泡（从下到上、从内到外）

    ```js
    window.addEventListener('click', function(event) {
        // event.target
    }, /* 是否使用捕获，默认是fasle */ fasle)
    ul  v-on
     li * 1000
    ```

- 事件委托/事件代理 *

   简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是 

   在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的 

   触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。 

   举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用 

   事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。 

   好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事 

   件触发机制

   -------

   监听父盒子，通过 `event.target`

- **事件循环EventLoop（比较复杂）**

- 闭包

  是指有权访问  **另外一个函数作用域中的变量** 的函数。

- 原型链、作用域链

   原型链

   ```js
   const obj = {
       a: '22'
   }
   // new Object()
   // obj.__proto__ ==> Object.prototype .__proto__ ==> null
   // obj.__proto__.__proto__.__proto__ ==> 直到找到值为null为止
   // obj.constructor ==> Object
   // 原型链
   obj.toString()
   ```

   作用域链

   ```js
   const f = '111'
   function a() {
       let b = 'xxx' 
       let f = '222'
       const test = () => {
           //   
           console.log('f', f)
       }
   }
   
   ```

- 垃圾回收机制

   - 标记清除： 进入环境、离开环境
   - 引用计数（不常用）：值被引用的次数， 当引用次数为零时会被清除（缺陷，相互引用的会有问题）

- #### 

- let、const和var的区别

   var  声明的变量会变成在全局作用域中会变成全局变量，还有可以重复声明

   let、const 

   - 不存在变量提升

   - 暂时性死区： 不能在声明之前访问

   - 不允许重复声明

   - 块级作用域：用let和const声明的变量，在这个块中会形成块级作用域

      **es5只有函数作用域和全局作用域**

      ```js
      function test(val) {
          if (val) {
              var temp = '222'
      	}
          console.log('temp', temp)
      }
      ```

      

   - IIFE `立即执行函数表达式`

     ```js
     // IIFE 写法	
     (function () {
       var tmp = ...;
       ...
     }());
     
     // 块级作用域写法
     {
       let tmp = ...;
       ...
     }
     ```

     ```js
      // 函数声明
       function a() {}
       // 函数表达式
       const b = function() {}
     ```

     



- reset参数

  ```js
  function add(...values) {
    let sum = 0;
  
    for (var val of values) {
      sum += val;
    }
  
    return sum;
  }
  
  add(2, 5, 3) // 10
  ```

- 扩展运算符

  ```js
  console.log(...[1, 2, 3])
  // 1 2 3
  ```

  



## 2022/2/2

### 缓存机制

#### 强缓存

> 如果命中强缓存--就不用像服务器去请求

1. `Expries` 设置时间，过期时间 	`expires: Tue, 15 Oct 2019 13:30:54 GMT`

   通过本地时间和 expires比较是否过期，如果过期了就去服务器请求，没有过期的话就直接使用本地的

   缺点：本地时间可能会更改， 导致缓存出错

2. `Cache-Control`  HTTP1.1中新增的

   - max-age 最大缓存多少毫秒，列如 `Cache-Control: max-age=2592000`

   - no-store (每次都要请求，就连协商缓存都不走)表示不进行缓存，缓存中不得存储任何关于客户端请求和服务端响应的内容。每次 由客户端发起的请求都会下载完整的响应内容。`Cache-Control: no-store`

   - no-cache（默认值）表示不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称 为 do-notserve-from-cache-without-revalidation 更合适。浏览器默认开启的是 no-cache，其 实这里也可理解为开启协商缓存 

   - public 和 private 

     public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念 

     当我们为资源设置了 pubile，那么它既可以被浏览器缓存也可被代理服务器缓存。设置为 

     private 的时候，则该资源只能被浏览器缓存，其中默认值是 private。 

   - max-age 和 s-maxage 

     s-maxage 只适用于供多用户使用的公共服务器上(如 CND cache)，并只对 public 缓存有效

#### 协商缓存

> 需要向服务器请求，如果没有过期，服务器会返回 304，

1.  **ETag 和 If-None-Match 唯一标识**

- 服务器响应 ETag值，浏览器携带的是 If-None-Match（携带的是上一次响应的ETag），服务拿到这 If-None-Match 值后判断过期--> 没有过期 304，并且返回 ETag

  ---

  二者的值都是服务器为每份资源分配的唯一标识字符串。 

  • 浏览器请求资源，服务器会在响应报文头中加入 ETag 字段。资源更新的时候，服务端的 

  ETag 值也随之更新 

  • 浏览器再次请求资源，会在请求报文头中添加 If-None-Match 字段，它的值就是上次响应 

  报文中的 ETag 值，服务器会对比 ETag 和 If-None-Match 的值是否一致。如果不一致，服务 

  器则接受请求，返回更新后的资源，状态码返回 200；如果一致，表明资源未更新，则返回 

  状态码 304，可继续使用本地缓存，值得注意的是此时响应头会加上 ETag 字段，即使它没 

  有变化

  ---

- **Last-Modified 和 If-Modified-Since  时间戳**
  缺点： 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)， 

  If-Modified-Since 可查到的是秒级，这种修改无法判断

  

## 2022/2/8

### 预编译

四部曲

1. 创建`AO`对象
2. 找形参和变量声明，将变量和形参名作为`AO`的属性名，值为`undefined`
3. 将实参值和形参值相统一
4. 在函数体里面找到函数声明，值赋予函数体



```JS
// 预编译
function foo(test/* 形参 */) {
    console.log(' test: ', test) // function(){}
    var test = 2
    var str = 'bs'
    console.log(' test: ', test) // 2
    // 函数声明
    function test() {}
	// 函数表达式
    str = function() {}
    console.log(' test: ', test) // 2
}

// 预编译 四部曲
// 1. 创建AO对象
// 2. 找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined
// 3. 将实参值和形参值相统一
// 4. 在函数体里面找到函数声明，值赋予函数体

// AO {
//   test: undefined
//   str: undefined
// }
// AO {
//   test: 1
//   str: undefined
// }
// AO {
//   test: 1
//   str: function() {}
// }


foo(1/*实参*/)

function foo (a, b, c) {
    console.log(a)
    console.log(b)
    var a = '222'
    function a() {}
    var b = function() {}
    console.log(a)
    console.log(b)

    console.log(' a, b, c: ', a, b, c)
}
// AO {
//   a : '222',
//   b : function() {},
//   c : 3
// }
foo(1, 2, 3)

var a = 22
// let a = 22
// window.a ==> 22
```



全局

1. 创建GO对象==window

2. 变量声明，将变量作为GO的属性名，值为`undefined`

3. 找到函数声明，值赋予函数体

   



### event-loop(事件循环)

> 参考 https://juejin.cn/post/6844903764202094606

**MacroTask（宏任务）***

- `script`全部代码、`setTimeout`、`setInterval`、`setImmediate`（浏览器暂时不支持，只有IE10支持，具体可见[`MDN`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FsetImmediate)）、`I/O`、`UI Rendering`。

**MicroTask（微任务）**

- `Process.nextTick（Node独有）`、`Promise.then`、`Object.observe(废弃)`、`MutationObserver`



#### 浏览器中

>  执行完一个宏任务，会执行所有的微任务

```js
console.log('script start');

setTimeout(function() {ss
  console.log('setTimeout');
}, 0);

new Promise((resolve) => {
  console.log('promise1');
  resolve()
}).then(function() {
  console.log('promise2');
});
console.log('script end');
```

执行结果

```
script start
promise1
script end
promise2
setTimeout
```



![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2ee35d1bcb45288b78885d2d1f4443~tplv-k3u1fbpfcp-zoom-1.image)





#### nodejs中

> 在11之前的版本，会在每个阶段之后执行所有的微任务
>
> 在11版本及之后，会每执行完一个宏任务，就会清空所用的微任务（和浏览器保存一致）

```js

new Promise(resolve => {
  console.log('new Promise 1')
  resolve()
}).then(() => {
  console.log('new Promise then')
})

setTimeout(() => {
  console.log('timer1')
  new Promise((resolve) => {
    console.log('timer1 new Promise')
    resolve()
  }).then(() => {
    console.log('timer1 new Promise then')
  })
  Promise.resolve().then(() => {
    console.log('timer1 Promise then')
  })
})

setTimeout(() => {
  console.log('timer2')
  Promise.resolve().then(() => {
    console.log('timer2 Promise then')
  })
})

console.log('start end')
```

在node11版本之前（不包含11）

```
new Promise 1
start end
new Promise then
timer1
timer1 new Promise
timer2
timer1 new Promise then
timer1 Promise then
timer2 Promise then
```

在node11版本及之后

```
new Promise 1
start end
new Promise then
timer1
timer1 new Promise
timer1 new Promise then
timer1 Promise then
timer2
timer2 Promise then
```





![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b222442fa0904f0d956565597e1fab17~tplv-k3u1fbpfcp-zoom-1.image)







## 2022/2/15

### 深拷贝和浅拷贝

> js的基本数据类型和复杂数据类型的区别（在堆和栈中，拷贝时的不同）

**基本类型和引用类型在内存上存储的区别**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89b70c934a0f436d90364287d706971a~tplv-k3u1fbpfcp-zoom-1.image)



```js
let obj = { b: 'xxx'}
let arr = [{a: 'ss'}, obj, 333]

// 赋值
let arr2 = arr
// 浅拷贝-只拷贝了一层，深层次的引用还是存在
let arr2 = arr.slice()
let arr2 = [...arr]
obj.b = '222' // arr2[1].b => 222
// arr[2] = 4444 ==> arr2[2] ===> 333

// 深拷贝
// 最简单的
let arr2 = JSON.parse(JSON.stringify(arr))
// undefined 丢失，如果里面有 函数，还有循环引用就会报错
// 自己封装，要递归处理
```



### webpack常用配置

```js
// webpack.config.js

const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");

function resolve(dir) {
  return path.join(__dirname, dir);
}

module.exports = {
  mode: "development",
  entry: {
    // 入口文件
    app: "./src/main.js",
  },
  output: {
    filename: "[name].js",
    // 输出目录
    path: resolve("dist"),
    // publicPath: './'
  },
  resolve: {
    // 扩展名--这样我们就可以不用写后缀名
    extensions: [".js", ".vue", ".json"],
    alias: {
      vue$: "vue/dist/vue.esm.js",
      "@": resolve("src"),
    },
  },
  module: {
    // 规则是从下到上，从右到左
    rules: [
      {
        test: /\.js$/,
        loader: "babel-loader",
        include: [resolve("src"), resolve("test")],
      },
      {
        test: /css|scss/,
        loader: ["style-loader", "css-loader", "sass-loader"],
      },
      {
        test: /\.svg$/,
        loader: "svg-sprite-loader",
        include: [resolve("src/icons")],
      },
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: "url-loader",
        exclude: [resolve("src/icons")],
        options: {
          limit: 10000,
          name: utils.assetsPath("img/[name].[hash:7].[ext]"),
        },
      },
      {
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
        loader: "url-loader",
        options: {
          limit: 10000,
          name: utils.assetsPath("media/[name].[hash:7].[ext]"),
        },
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: "url-loader",
        options: {
          limit: 10000,
          name: utils.assetsPath("fonts/[name].[hash:7].[ext]"),
        },
      },
    ],
  },
  // 引入外部库, 无需webpack打包处理
  externals: {
    mockjs: "Mock",
    echarts: "echarts",
    ueditor: "UE",
  },
  plugins: [
    new HtmlWebpackPlugin({
      filename: "index.html",
      template: "index.html", // 模板文件
    }),
  ],
};
```



## 2020/2/18

### vue3生命周期

| 选项式 API        | Hook inside `setup` |
| ----------------- | ------------------- |
| `beforeCreate`    | Not needed*         |
| `created`         | Not needed*         |
| `beforeMount`     | `onBeforeMount`     |
| `mounted`         | `onMounted`         |
| `beforeUpdate`    | `onBeforeUpdate`    |
| `updated`         | `onUpdated`         |
| `beforeUnmount`   | `onBeforeUnmount`   |
| `unmounted`       | `onUnmounted`       |
| `errorCaptured`   | `onErrorCaptured`   |
| `renderTracked`   | `onRenderTracked`   |
| `renderTriggered` | `onRenderTriggered` |
| `activated`       | `onActivated`       |
| `deactivated`     | `onDeactivated`     |

### 基本代码

#### main.js

```js
// main.js
import { createApp } from "vue";
import App from "./App.vue";

import HelloWorld from "./components/HelloWorld.vue";
const app = createApp(App);

// 全局组件
app.component("HelloWorld", HelloWorld);

// Vue.prototype.$http
app.config.globalProperties.$http = () => {
  console.log("http ==");
};

app.mount("#app");

```



#### App.vue

```html
<!--- App.vue  -->
<template>
  <img alt="Vue l`ogo" src="./assets/logo.png" />
  <div>
    <!-- v-model="xxx"  <==> v-model:modelValue="xxx" -->
    <!-- :value="xxx" @input="xxx = $event" -->
    <!-- value $emit('input', '传递') -->

    <!-- 
      visible.sync="visible" 
      ==>
      :visible="visible" @update:visible="visible = $event"
      -->

    <!-- vue3 把 .sync 去掉，==> 
        v-model:visible="visible"
       -->

    <!--     
    <div :ref="setDivRef">
      count: {{ count }}
      <p>
        <button @click="add">+</button>
        <button @click="reduce">-</button>
      </p>
    </div>

    <ul>
      <li>姓名：{{ user.name }}</li>
      <li>年龄：{{ user.age }}</li>
    </ul> -->

      <!-- v-model="num" -->
    <Child
      title="父组件传递的title"
      :modelValue="num"
      @update:modelValue="num = $event"
      
      @change="onChildChange"
      v-model:visible="visible"
      ref="childRef"
    ></Child>
    <!-- <HelloWorld></HelloWorld> -->
  </div>
</template>

<script>
import Child from './Child-setup.vue'
import { reactive, ref } from '@vue/reactivity'
import { onMounted, provide } from '@vue/runtime-core'
export default {
  components: { Child },
  // data() {
  //   return {
  //     msg: '哈哈哈',
  //   }
  // },
  setup() {
    const msg = ref('哈哈哈2') // => reactive({value: 哈哈哈2 })
    const obj = ref({ x: 'xx' })
    console.log(' obj.value: ', obj.value)
    const user = reactive({ name: '张三', age: 18 })
    const count = ref(0)
    

    provide('count', count)
    provide('http', () => {
      console.log('$http >>>')
    })

    const add = () => {
      count.value++
    }

    const reduce = () => {
      count.value--
    }

    const num = ref(1)
    const visible = ref(false)

    // this.$refs.childRef x
    // refs
    // 1. 用字符串
    const childRef = ref(null)
    onMounted(() => {
      console.log(' childRef.value: ', childRef.value)
    })

    let divRef
    const setDivRef = (el) => {
      console.log(' el: ', el)
      divRef = el
    }

    return {
      msg,
      user,
      count,
      add,
      reduce,
      num,
      visible,
      childRef,
      setDivRef,
    }
  },

  methods: {
    onChildChange() {},
  },
}
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>

```

#### Child-composition （组合式api）

```html
<template>
  <!-- 
  1. 多个片段， 多个根标签 
  2. v-for v-if 优先级变化 v3 v-if > v-for
-->
  <div>
    <button @click="triggerEvent">触发事件</button>

    <div>num2：{{ num2 }}</div>
    <div>count：{{ count }}</div>

    modelValue：{{ modelValue }}
    <button @click="add">+</button>
    <hr />
    visible：{{ visible }}
    <button @click="updateVisible">更新visible</button>

    <!--  -->
    <teleport to="body">
      <div v-if="visible">對話框</div>
    </teleport>
  </div>
</template>

<script>
import {
  computed,
  inject,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onMounted,
  onUnmounted,
  onUpdated,
  watch,
  watchEffect,
} from '@vue/runtime-core'
export default {
  props: {
    title: String,
    modelValue: Number,
    visible: Boolean,
  },
  // computed: {
  //   num2() {
  //     return this.modelValue * 2
  //   }
  // },
  emits: ['change', 'update:modelValue', 'update:visible'],
  // 发生在 beforeCreate
  // attrs 除了 class style,props 之外的属性
  //

  // watch: {
  //   title: {
  //     deep: true, // 深度简单

  //   }
  // },
  // 组合式API(composition),  选项式API(options)
  setup(props, { emit, attrs, slots }) {
    console.log(' attrs: ', attrs)
    console.log(' props: ', props)

    // computed
    const num2 = computed(() => props.modelValue * 2)
    // const num2 = computed({
    //   get: () => props.modelValue * 2,
    //   set: (val) => {
    //     ssss
    //   }
    // })

    //
    const count = inject('count')
    console.log(' count: ', count)

    // watch
    // this.$watch()
    const unwatch = watch(
      () => props.modelValue,
      (newVal, oldValue) => {
        console.log(' newVal: ', newVal)
        if (newVal >= 10) {
          // 取消监听
          unwatch()
        }
      },
      {
        deep: true,
        // immediate: true
      }
    )

    // 自动收集依赖，所以会初始化的时候就执行一次
    watchEffect(() => {
      console.log(' props.modelValue: ', props.modelValue)
    })

    // hooks
    onBeforeMount(() => {})
    onMounted(() => {
      console.log('哈哈哈')
    })
    onBeforeUpdate(() => {})
    onUpdated(() => {})
    onBeforeUnmount(() => {})
    onUnmounted(() => {})
    
    // keep-alive
    onActivated(() => {})
    onDeactivated(() => {})

    // methods
    const triggerEvent = () => {
      emit('change', '传递的数据')
    }

    const add = () => {
      emit('update:modelValue', props.modelValue + 1)
    }
    const updateVisible = () => {
      console.log(' props.visible: ', props.visible)
      emit('update:visible', !props.visible)
    }

    return {
      triggerEvent,
      add,
      updateVisible,
      num2,
      count,
    }
  },
  // beforeCreate() {
  //   console.log('beforeCreate')
  // },
  // created() {
  //   console.log('created')
  // },

  // beforeDestroy beforeUnmount
  // destroyed unmounted
}
</script>
```



#### Child-setup

```html
<template>
  <div>
    <p>title: {{ title }}</p>
    <p>num2: {{ num2 }}</p>
    <p>count: {{ count }}</p>

    <div>
      modelValue：{{ modelValue }}
      <button @click="add">+</button>
    </div>

    <button @click="triggerEvent">触发事件</button>

    <!-- <input type="text" v-model="inputValue"> -->
    <!--   -->
    <input type="text" :value="inputValue" @input="onInputUpdate">

    <!-- volar -->
    <Foo></Foo>
  </div>
</template>

<!--- vue 3.2.x -->
<script setup>
import {
  computed,
  getCurrentInstance,
  inject,
  ref,
  useAttrs,
  useSlots,
} from '@vue/runtime-core'
import Foo from './foo.vue'

// props
const props = defineProps({
  title: String,
  modelValue: Number,
})
// computed
const num2 = computed(() => props.modelValue * 2)
const count = inject('count')

// emit
const emit = defineEmits(['change', 'update:modelValue', 'update:visible'])
const triggerEvent = () => {
  emit('change', '传递的数据')
}
const add = () => {
  emit('update:modelValue', props.modelValue + 1)
}

// 向父组件暴露自己的属性和方法
defineExpose({
  num2,
  test() {
    console.log('888')
  },
})

const attrs = useAttrs()
console.log(' attrs: ', attrs)
const solts = useSlots()

const ctx = getCurrentInstance()

const http = ctx.appContext.config.globalProperties.$http
http('xxx')

const $http = inject('http')
$http()

// $ref: ref(false)

const inputValue = ref('')

const onInputUpdate = (event) => {
  console.log(' event: ', event)
  inputValue.value = event.target.value
}
</script>

```



### https 和http 的区别

https(http + ssl/tls)

- 明文： 普通的文本

- 密钥：把明文加密的那个钥匙

- 密文： 把明文加密

  明文+密钥==>密文==>密钥==解密=>明文

- 对称加密  解密的key（密钥）和解密的key是同一个 3 + 1 
- 非对称加密   私钥和公钥 


![无标题.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/489428dbcc4840d689ed717d4335a833~tplv-k3u1fbpfcp-watermark.image?)


